/*!
  * Polyficky (Stickyfill Reborn) – `position: sticky` polyfill
  * v. 1.0.0 | https://github.com/trevonerd/polyficky
  * MIT License
  */'use strict';/*
  * 1. Check if the browser supports `position: sticky` natively or is too old to run the polyfill.
  *    If either of these is the case set `seppuku` flag. It will be checked later to disable key features
  *    of the polyfill, but the API will remain functional to avoid breaking things.
  */function _classCallCheck(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}function _defineProperties(a,b){for(var c,d=0;d<b.length;d++)c=b[d],c.enumerable=c.enumerable||!1,c.configurable=!0,"value"in c&&(c.writable=!0),Object.defineProperty(a,c.key,c)}function _createClass(a,b,c){return b&&_defineProperties(a.prototype,b),c&&_defineProperties(a,c),a}var seppuku=!1,isWindowDefined="undefined"!=typeof window;// The polyfill can’t function properly without `window` or `window.getComputedStyle`.
if(!isWindowDefined||!window.getComputedStyle)seppuku=!0;// Dont’t get in a way if the browser supports `position: sticky` natively.
else{var testNode=document.createElement("div");["","-webkit-","-moz-","-ms-"].some(function(a){try{testNode.style.position="".concat(a,"sticky")}catch(a){return!1}return""!=testNode.style.position})&&(seppuku=!0)}/*
  * 2. “Global” vars used across the polyfill
  */var isInitialized=!1,shadowRootExists="undefined"!=typeof ShadowRoot,scroll={top:null,left:null},stickies=[];// Check if Shadow Root constructor exists to make further checks simpler
/*
  * 3. Utility functions
  */function extend(a,b){for(var c in b)Object.prototype.hasOwnProperty.call(b,c)&&(a[c]=b[c])}function parseNumeric(a){return parseFloat(a)||0}function getDocOffsetTop(a){for(var b=0,c=a;c;)b+=c.offsetTop,c=c.offsetParent;return b}/*
  * 4. Sticky class
  */var Sticky=/*#__PURE__*/function(){function a(b){var c=1<arguments.length&&void 0!==arguments[1]?arguments[1]:0;if(_classCallCheck(this,a),!(b instanceof HTMLElement))throw new Error("First argument must be HTMLElement");if(stickies.some(function(a){return a._node===b}))throw new Error("Polyficky is already applied to this node");this._node=b,this._stickyMode=null,this._active=!1,this._customOffset=c,stickies.push(this),this.refresh()}return _createClass(a,[{key:"refresh",value:function refresh(){if(!(seppuku||this._removed)){this._active&&this._deactivate();var a=this._node,b=getComputedStyle(a),c={position:b.position,top:b.top,display:b.display,marginTop:b.marginTop,marginBottom:b.marginBottom,marginLeft:b.marginLeft,marginRight:b.marginRight,cssFloat:b.cssFloat};/*
          * 1. Save node computed props
          */ /*
          * 2. Check if the node can be activated
          */if(!(isNaN(parseFloat(c.top))||"table-cell"==c.display||"none"==c.display)){this._active=!0;/*
          * 3. Check if the current node position is `sticky`. If it is, it means that the browser supports sticky positioning,
          *    but the polyfill was force-enabled. We set the node’s position to `static` before continuing, so that the node
          *    is in it’s initial position when we gather its params.
          */var d=a.style.position;("sticky"==b.position||"-webkit-sticky"==b.position)&&(a.style.position="static");/*
          * 4. Get necessary node parameters
          */var e=a.parentNode,f=shadowRootExists&&e instanceof ShadowRoot?e.host:e,g=a.getBoundingClientRect(),h=f.getBoundingClientRect(),i=getComputedStyle(f);this._parent={node:f,styles:{position:f.style.position},offsetHeight:f.offsetHeight},this._offsetToWindow={left:g.left,right:document.documentElement.clientWidth-g.right},this._offsetToParent={top:g.top-h.top-parseNumeric(i.borderTopWidth),left:g.left-h.left-parseNumeric(i.borderLeftWidth),right:-g.right+h.right-parseNumeric(i.borderRightWidth)},this._styles={position:d,top:a.style.top,bottom:a.style.bottom,left:a.style.left,right:a.style.right,width:a.style.width,marginTop:a.style.marginTop,marginLeft:a.style.marginLeft,marginRight:a.style.marginRight};var j=parseNumeric(c.top);this._limits={start:g.top+window.pageYOffset-j+this._customOffset,end:h.top+window.pageYOffset+f.offsetHeight-parseNumeric(i.borderBottomWidth)-a.offsetHeight-j-parseNumeric(c.marginBottom)};/*
          * 5. Ensure that the node will be positioned relatively to the parent node
          */var k=i.position;"absolute"!=k&&"relative"!=k&&(f.style.position="relative"),this._recalcPosition();/*
          * 7. Create a clone
          */var l=this._clone={};l.node=document.createElement("div"),extend(l.node.style,{width:"".concat(g.right-g.left,"px"),height:"".concat(g.bottom-g.top,"px"),marginTop:c.marginTop,marginBottom:c.marginBottom,marginLeft:c.marginLeft,marginRight:c.marginRight,cssFloat:c.cssFloat,padding:0,border:0,borderSpacing:0,fontSize:"1em",position:"static"}),e.insertBefore(l.node,a),l.docOffsetTop=getDocOffsetTop(l.node)}}}},{key:"_recalcPosition",value:function _recalcPosition(){if(this._active&&!this._removed){var a=scroll.top<=this._limits.start?"start":scroll.top>=this._limits.end?"end":"middle";this._stickyMode!=a&&("start"==a?extend(this._node.style,{position:"absolute",left:"".concat(this._offsetToParent.left,"px"),right:"".concat(this._offsetToParent.right,"px"),top:"".concat(this._offsetToParent.top-this._customOffset,"px"),bottom:"auto",width:"auto",marginLeft:0,marginRight:0,marginTop:0}):"middle"===a?extend(this._node.style,{position:"fixed",left:"".concat(this._offsetToWindow.left,"px"),right:"".concat(this._offsetToWindow.right,"px"),top:this._styles.top,bottom:"auto",width:"auto",marginLeft:0,marginRight:0,marginTop:"".concat(0-this._customOffset,"px")}):"end"===a?extend(this._node.style,{position:"absolute",left:"".concat(this._offsetToParent.left,"px"),right:"".concat(this._offsetToParent.right,"px"),top:"auto",bottom:"".concat(0+this._customOffset,"px"),width:"auto",marginLeft:0,marginRight:0}):void 0,this._stickyMode=a)}}},{key:"_fastCheck",value:function _fastCheck(){var a=Math.abs;!this._active||this._removed||(1<a(getDocOffsetTop(this._clone.node)-this._clone.docOffsetTop)||1<a(this._parent.node.offsetHeight-this._parent.offsetHeight))&&this.refresh()}},{key:"_deactivate",value:function _deactivate(){var a=this;!this._active||this._removed||(this._clone.node.parentNode.removeChild(this._clone.node),delete this._clone,extend(this._node.style,this._styles),delete this._styles,!stickies.some(function(b){return b!==a&&b._parent&&b._parent.node===a._parent.node})&&extend(this._parent.node.style,this._parent.styles),delete this._parent,this._stickyMode=null,this._active=!1,delete this._offsetToWindow,delete this._offsetToParent,delete this._limits)}},{key:"remove",value:function remove(){var a=this;this._deactivate(),stickies.some(function(b,c){if(b._node===a._node)return stickies.splice(c,1),!0}),this._removed=!0}}]),a}(),Polyficky={stickies:stickies,Sticky:Sticky,forceSticky:function forceSticky(){seppuku=!1,init(),this.refreshAll()},addOne:function addOne(a,b){var c=a;// Check whether it’s a node
if(!(c instanceof HTMLElement))// Maybe it’s a node list of some sort?
// Take first node from the list then
if(c.length&&c[0])c=c[0];else return;// Check if Polyficky is already applied to the node
// and return existing sticky
for(var d=0;d<stickies.length;d++)if(stickies[d]._node===c)return stickies[d];// Create and return new sticky
return new Sticky(c,b)},add:function add(a){var b=a;// If it’s a node make an array of one node
// Check if the argument is an iterable of some sort
if(b instanceof HTMLElement&&(b=[b]),!!b.length){for(var c,d=[],e=function(a){var c=b[a];// If it’s not an HTMLElement – create an empty element to preserve 1-to-1
// correlation with input list
return c instanceof HTMLElement?stickies.some(function(a){if(a._node===c)return d.push(a),!0})?"continue":void// Create and add new sticky
d.push(new Sticky(c)):(d.push(void 0),"continue");// If Polyficky is already applied to the node
// add existing sticky
},f=0;f<b.length;f++)c=e(f),"continue"===c;return d}// Add every element as a sticky and return an array of created Sticky instances
},refreshAll:function refreshAll(){stickies.forEach(function(a){return a.refresh()})},removeOne:function removeOne(a){var b=a;// Check whether it’s a node
if(!(b instanceof HTMLElement))// Maybe it’s a node list of some sort?
// Take first node from the list then
if(b.length&&b[0])b=b[0];else return;// Remove the stickies bound to the nodes in the list
stickies.some(function(a){if(a._node===b)return a.remove(),!0})},remove:function remove(a){var b=a;// If it’s a node make an array of one node
// Check if the argument is an iterable of some sort
if(b instanceof HTMLElement&&(b=[b]),!!b.length)// Remove the stickies bound to the nodes in the list
for(var c=function(a){var c=b[a];stickies.some(function(a){if(a._node===c)return a.remove(),!0})},d=0;d<b.length;d++)c(d)},removeAll:function removeAll(){for(;stickies.length;)stickies[0].remove()}};/*
  * 5. Polyficky API
  */ /*
  * 6. Setup events (unless the polyfill was disabled)
  */function init(){// Watch for scroll position changes and trigger recalc/refresh if needed
function a(){window.pageXOffset==scroll.left?window.pageYOffset!=scroll.top&&(scroll.top=window.pageYOffset,scroll.left=window.pageXOffset,stickies.forEach(function(a){return a._recalcPosition()})):(scroll.top=window.pageYOffset,scroll.left=window.pageXOffset,Polyficky.refreshAll())}function b(){d=setInterval(function(){stickies.forEach(function(a){return a._fastCheck()})},500)}function c(){clearInterval(d)}if(!isInitialized){isInitialized=!0,a(),window.addEventListener("scroll",a),window.addEventListener("resize",Polyficky.refreshAll),window.addEventListener("orientationchange",Polyficky.refreshAll);//Fast dirty check for layout changes every 500ms
var d,e,f;"hidden"in document?(e="hidden",f="visibilitychange"):"webkitHidden"in document&&(e="webkitHidden",f="webkitvisibilitychange"),f?(!document[e]&&b(),document.addEventListener(f,function(){document[e]?c():b()})):b()}}seppuku||init(),"undefined"!=typeof module&&module.exports?module.exports=Polyficky:isWindowDefined&&(window.Polyficky=Polyficky);
